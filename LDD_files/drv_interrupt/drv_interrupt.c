// How to run the module.
//$ sudo insmod drv_interrupt.ko
//$ sudo rmmod drv_interrupt

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include<linux/sysfs.h> 
#include<linux/kobject.h> 

#include <linux/interrupt.h>

MODULE_LICENSE("GPL");

#define IRQ_NO 10

//Interrupt handler (Interrupt Service Routine (ISR)) 
static irqreturn_t my_irq_handler(int irq, void *data)
{
  printk(KERN_INFO "my_irq_handler() - IRQ 10 raised.\n");
  return IRQ_HANDLED;
}

struct kobject *kobj_ref;

static ssize_t  km_interrupt_show(struct kobject *kobj, 
                        struct kobj_attribute *attr, char *buf)
{
        printk(KERN_INFO "km_interrupt_show() - sysfs read operation\n");

        /*
         * The following code is assembly instruction to artificially inject
         * interrupt in the system via sysFS backdoor. Note that a real device
         * driver (where the interrupt is generated by the device) will never
         * do this. This code is written merely for the purpose of demonstration         * of interrupt handling. 
         */
        asm("int $0x3A");  // IRQ Vector 0X3A corresponding to IRQ 10 

        return 0; 
}

static ssize_t  km_interrupt_save(struct kobject *kobj, 
                        struct kobj_attribute *attr,const char *buf, size_t count)
{
        printk(KERN_INFO "km_interrupt_save() - sysfs write operation\n");

        /*
         * The following code is assembly instruction to artificially inject
         * interrupt in the system via sysFS backdoor. Note that a real device
         * driver (where the interrupt is generated by the device) will never
         * do this. This code is written merely for the purpose of demonstration         * of interrupt handling. 
         */
        asm("int $0x3A");  // IRQ Vector 0X3A corresponding to IRQ 10 

        return count;
}

struct kobj_attribute km_interrupt_attr = __ATTR(raise_int, 0660, km_interrupt_show, km_interrupt_save);


static int __init start_module(void)
{
    printk(KERN_INFO "Hello Kernel\n");

    // Creating sys FS dir under /sys/kernel
    kobj_ref = kobject_create_and_add("km_interrupt_sysfs_dir",kernel_kobj);
    if (kobj_ref == NULL)
    {
         printk("Failed to create sysfs dir.\n");
         return -1;
    }
 
    // Creating sys FS file in  
    if(sysfs_create_file(kobj_ref,&km_interrupt_attr.attr))
    {
         printk("Failed to create sysfs file.\n");
         goto sysfs_file_err;
    }
 
    if (request_irq(IRQ_NO, my_irq_handler, IRQF_SHARED, "km_interrupt_device", (void *)(my_irq_handler))) {
        printk(KERN_INFO "km_interrupt_device: cannot register interrupt handler\n");
        goto irq_err;
    }

    return 0;

irq_err:
    sysfs_remove_file(kernel_kobj, &km_interrupt_attr.attr);

sysfs_file_err:
    kobject_put(kobj_ref); 

    return -1;
}

static void __exit end_module(void)
{
    printk(KERN_INFO "Bye-bye Kernel\n");

    free_irq(IRQ_NO, (void *)(my_irq_handler));
    sysfs_remove_file(kernel_kobj, &km_interrupt_attr.attr);
    kobject_put(kobj_ref); 

    return ;
}
module_init(start_module);
module_exit(end_module);

